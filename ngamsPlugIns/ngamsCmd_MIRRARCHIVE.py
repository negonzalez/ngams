#
#    ALMA - Atacama Large Millimiter Array
#    (c) European Southern Observatory, 2002
#    Copyright by ESO (in the framework of the ALMA collaboration),
#    All rights reserved
#
#    This library is free software; you can redistribute it and/or
#    modify it under the terms of the GNU Lesser General Public
#    License as published by the Free Software Foundation; either
#    version 2.1 of the License, or (at your option) any later version.
#
#    This library is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#    Lesser General Public License for more details.
#
#    You should have received a copy of the GNU Lesser General Public
#    License along with this library; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
#    MA 02111-1307  USA
#

#******************************************************************************
#
# "@(#) $Id: ngamsCmd_MIRRARCHIVE.py,v 1.24 2012/11/22 21:48:22 amanning Exp $"
#
# Who       When        What
# --------  ----------  -------------------------------------------------------
# jagonzal  2010/17/01  Created
#

"""
NGAS Command Plug-In, implementing an Archive Command specific for Mirroring 

This works in a similar way as the 'standard' ARCHIVE Command, but has been
simplified in a few ways:
  
  - No replication to a Replication Volume is carried out.
  - Target disks are selected randomly, disregarding the Streams/Storage Set
    mappings in the configuration. This means that 'volume load balancing' is
    provided.
  - Archive Proxy Mode is not supported.
  - No probing for storage availability is supported.
  - In general, less SQL queries are performed and the algorithm is more
    light-weight.
  - crc is computed from the incoming stream
  - ngas_files data is 'cloned' from the source file
"""

from ngams import TRACE, info, getHostId, genLog, getDiskSpaceAvail, mvFile, getFileCreationTime, NGAMS_ONLINE_STATE, NGAMS_FILE_STATUS_OK, timeRef2Iso8601
from ngams.ngamsLib import ngamsDbCore, ngamsDiskInfo
from pcc.pccUt import PccUtTime
import os
import binascii
import ngamsDAPIMirroring
from ngamsFailedDownloadException import *
import ngamsCmd_HTTPFETCH
import ngamsCmd_RSYNCFETCH

GET_AVAIL_VOLS_QUERY = "SELECT %s FROM ngas_disks nd WHERE completed=0 AND " +\
                       "host_id='%s' order by available_mb desc"


def getTargetVolume(srvObj):
    """
    Get a random target volume with availability.

    srvObj:         Reference to NG/AMS server class object (ngamsServer).
        
    Returns:        Target volume object or None (ngamsDiskInfo | None).
    """
    TRACE()
    
    sqlQuery = GET_AVAIL_VOLS_QUERY % (ngamsDbCore.getNgasDisksCols(),
                                       getHostId())
    res = srvObj.getDb().query(sqlQuery, ignoreEmptyRes=0)
    if (res == [[]]):
        return None
    else:
        return ngamsDiskInfo.ngamsDiskInfo().unpackSqlResult(res[0][0])

def updateDiskInfo(srvObj,
                   resDapi,
                   availSpace):
    """
    Update the row for the volume hosting the new file.

    srvObj:     Reference to NG/AMS server class object (ngamsServer).

    resDapi:    Result returned from the DAPI (ngamsDapiStatus).
 
    availSpace: Remaining space in disk (in mb)

    Returns:   Void.
    """
    TRACE()

    sqlQuery = "UPDATE ngas_disks SET " +\
               "number_of_files=(number_of_files + 1), " +\
               "available_mb = :availableMb, " +\
               "bytes_stored = (bytes_stored + :fileSize) WHERE " +\
               "disk_id = :diskId"
    srvObj.getDb().query(sqlQuery, parameters = {"availableMb": availSpace, "fileSize": resDapi.getFileSize(), "diskId": resDapi.getDiskId()})


def saveInStagingFile(srvObj, 
                      ngamsCfgObj,
                      reqPropsObj,
                      stagingFilename,
                      startByte):
    """
    Save the data ready on the HTTP channel, into the given Staging
    Area file.

    ngamsCfgObj:     NG/AMS Configuration (ngamsConfig).
    
    reqPropsObj:     NG/AMS Request Properties object (ngamsReqProps).
        
    stagingFilename: Staging Area Filename as generated by
                     ngamsHighLevelLib.genStagingFilename() (string).

    diskInfoObj:     Disk info object. Only needed if mutual exclusion
                     is required for disk access (ngamsDiskInfo).

    Returns:         Void.
    """
    TRACE()

    blockSize = ngamsCfgObj.getBlockSize()
    fetchMethod = 'HTTP'
    if ngamsCfgObj.getVal("Mirroring[1].fetch_method"):
        fetchMethod = ngamsCfgObj.getVal("Mirroring[1].fetch_method")
    if fetchMethod == 'RSYNC':
        info = ngamsCmd_RSYNCFETCH.saveToFile(srvObj, ngamsCfgObj, reqPropsObj, stagingFilename,
                                  blockSize, startByte)
    else:
        info = ngamsCmd_HTTPFETCH.saveToFile(srvObj, ngamsCfgObj, reqPropsObj, stagingFilename,
                                  blockSize, startByte)
    return info

def calculateCrc(filename, blockSize):
    crc = 0
    try:
        fdin = open(filename, "r")
        buff = "-"
        while len(buffer) > 0:
            buff = fdin.read(blockSize)
            crc = binascii.crc32(buff, crc)
    finally:
        fdin.close()
    return crc

def handleCmd(srvObj,
              reqPropsObj):
    if srvObj.getState() == NGAMS_ONLINE_STATE:
        __handleCmd(srvObj, reqPropsObj)
    else:
        raise AbortedException("Server is OFFLINE")
        
def __handleCmd(srvObj,
              reqPropsObj):
    """
    Handle the Mirroring Archive (MIRRARCHIVE) Command.
        
    srvObj:         Reference to NG/AMS server class object (ngamsServer).setState
    
    
    reqPropsObj:    Request Property object to keep track of actions done
                    during the request handling (ngamsReqProps).
        
    Returns:        Void.
    """
    TRACE()

    # Is this NG/AMS permitted to handle Archive Requests?
    info(4, "Checking if this NG/AMS permitted to handle Archive Requests?")
    if (not srvObj.getCfg().getAllowArchiveReq()):
        errMsg = genLog("NGAMS_ER_ILL_REQ", ["Archive"])
        raise Exception, errMsg
    
    # Generate staging filename.
    stgFilename = reqPropsObj.getStagingFilename()
    info(3, "staging filename is: %s" % stgFilename)
    startByte = 0
    if (os.path.exists(stgFilename) == 0):
        info(3, 'this is a new staging file')
    else:
        startByte = os.path.getsize(stgFilename)
        info(3, 'staging file already exists, requesting resumption of download from byte ' + str(startByte))

    # Set reference in request handle object to the read socket.
    try:
        # Retrieve file_id and file_version from request proposal
        file_id = reqPropsObj.getFileInfo()['fileId']
        file_version = reqPropsObj.getFileInfo()['fileVersion']
        info(4, "Got file_id=%s and file_version=%s" % (file_id,file_version))
   
        # Retrieve file contents (from URL, archive pull, or by storing the body
        # of the HTTP request, archive push).
        info(2, "Saving in staging file: %s" % stgFilename)
        stagingInfo = saveInStagingFile(srvObj, srvObj.getCfg(), reqPropsObj,
                                        stgFilename, startByte)
        reqPropsObj.incIoTime(stagingInfo[0])
        checksumPlugIn = "ngamsGenCrc32"
        checksum = stagingInfo[1]
        reqPropsObj.setChecksum(checksum)
    except FailedDownloadException, e:
        raise
    except PostponeException, e:
        raise
    except Exception, e:
        if reqPropsObj.getBytesReceived() >= 0:
            info(3, "the fetch has already downloaded data. marking as TORESUME")
            raise PostponeException(e)
        else:
            info(3, "no data has been downloaded yet. Marking as FAILURE")
            raise FailedDownloadException(e)

    # Invoke DAPI
    info(2, "Invoking DAPI")
    resDapi = ngamsDAPIMirroring.ngamsGeneric(srvObj,reqPropsObj)

    # Move file to final destination.
    info(2, "Moving file to final destination")
    ioTime = mvFile(reqPropsObj.getStagingFilename(),resDapi.getCompleteFilename())
    reqPropsObj.incIoTime(ioTime)
   
    # Check/generate remaining file info + update in DB.
    info(2, "Creating db entry")
    ts = PccUtTime.TimeStamp().getTimeStamp()
    creDate = timeRef2Iso8601(getFileCreationTime(resDapi.getCompleteFilename()))
    sqlQuery = "INSERT INTO ngas_files " +\
               "(disk_id, file_name, file_id, file_version, " +\
               "format, file_size, " +\
               "uncompressed_file_size, compression, " +\
               "ingestion_date, ignore, checksum, " +\
               "checksum_plugin, file_status, creation_date) "+\
               "VALUES " +\
               "(:1, :2, :3, :4," +\
               " :5, :6," +\
               " :7, :8," +\
               " :9, :10, :11," +\
               " :12, :13, :14)"
    parameters = [
        str(resDapi.getDiskId()), str(resDapi.getRelFilename()) , file_id, file_version,
        str(resDapi.getFormat()), str(resDapi.getFileSize()),
        str(resDapi.getUncomprSize()), str(resDapi.getCompression()),
        str(ts), str(0), str(checksum), 
        str(checksumPlugIn), NGAMS_FILE_STATUS_OK, str(creDate)
    ]
    srvObj.getDb().query(sqlQuery, maxRetries = 0, parameters = parameters)
    
    # Check if the disk is completed.
    info(2, "Check available space in disk")
    targDiskInfo = reqPropsObj.getTargDiskInfo()
    info(3, 'mount point is ' + str(targDiskInfo.getMountPoint()))
    availSpace = getDiskSpaceAvail(targDiskInfo.getMountPoint(), smart=True)

    # Update disk info in NGAS Disks.
    info(2, "Update disk info in NGAS Disks.")
    updateDiskInfo(srvObj, resDapi, availSpace)

    # Check if the disk is completed.
    if (availSpace < srvObj.getCfg().getFreeSpaceDiskChangeMb()):
        complDate = PccUtTime.TimeStamp().getTimeStamp()
        targDiskInfo.setCompleted(1).setCompletionDate(complDate)
        targDiskInfo.write(srvObj.getDb())

    # Final log message
    info(2, "Successfully handled Archive Pull Request for data file with URI: %s" % \
            reqPropsObj.getSafeFileUri())

    return

# EOF

